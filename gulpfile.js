var settings = {
	clean: true,
	scripts: true,
	polyfills: true,
	styles: true,
	svgs: true,
	copy: true,
	reload: true
};

var paths = {
	input: 'src/',
	output: 'dist/',
	templates: {
		input: "src/templates/*.html",
		output: "dist/templates",
		compiled: "dist/compiled"
	},
	index: {
		input: "src/index.html",
		output: "dist/"
	},
	styles: {
		input: 'src/styles/**/*.{scss,sass}',
		output: 'dist/styles/'
	},
	assets: {
		input: 'src/assets/**/*.*',
		output: 'dist/assets/'
	},
	svgs: {
		input: 'src/svg/*.svg',
		output: 'dist/svg/'
	},
	reload: './dist/'
};

var {gulp, src, dest, watch, series, parallel} = require('gulp');
var del = require('del');
var rename = require('gulp-rename');
var injectPartials = require('gulp-inject-partials');

// CSS
var sass = require('gulp-sass');
var postcss = require('gulp-postcss');
var appendPrepend = require('gulp-append-prepend');
var prefix = require('autoprefixer');
var minify = require('cssnano');
var inlineCss = require('gulp-inline-css');

var htmlmin = require('gulp-htmlmin');

// SVGs
var svgmin = require('gulp-svgmin');

// BrowserSync
var browserSync = require('browser-sync');
const { create } = require('browser-sync');



// Remove pre-existing content from output folders
var cleanDist = function (done) {

	// Make sure this feature is activated before running
	if (!settings.clean) return done();

	// Clean the dist folder
	del.sync([
		paths.output
	]);

	// Signal completion
	return done();

};


// Process, lint, and minify Sass files
var buildStyles = function (done) {

	// Make sure this feature is activated before running
	if (!settings.styles) return done();

	// Run tasks on all Sass files
	return src(paths.styles.input)
		.pipe(sass({
			outputStyle: 'expanded',
			sourceComments: true
		}))
		.pipe(postcss([
			prefix({
				cascade: true,
				remove: true
			})
		]))
		.pipe(dest(paths.styles.output))
		.pipe(rename({suffix: '.min'}))
		.pipe(postcss([
			minify({
				discardComments: {
					removeAll: true
				}
			})
		]))
		.pipe(dest(paths.styles.output));

};

var compileIndex = function(done) {
	return src(paths.index.input)
		.pipe(injectPartials())
		.pipe(dest(paths.index.output))
}

var compileTemplates = function(done) {
	return src(paths.templates.input)
		.pipe(injectPartials())
		.pipe(dest(paths.templates.output))
}

var copyAssets = function(done) {
	return src(paths.assets.input)
		.pipe(dest(paths.assets.output))
}

var buildEmail = function (done) {
	return src(paths.templates.output+"/*.html")
		.pipe(appendPrepend.prependText('<link rel="stylesheet" href="../styles/index.css">'))
		.pipe(inlineCss({
			removeStyleTags: false
		}))
		.pipe(htmlmin({ 
			collapseWhitespace: true,
			removeComments: true,
		}))
        .pipe(dest(paths.templates.compiled));
}

// Watch for changes to the src directory
var startServer = function (done) {

	// Make sure this feature is activated before running
	if (!settings.reload) return done();

	// Initialize BrowserSync
	browserSync.init({
		server: {
			baseDir: paths.reload
		}
	});

	// Signal completion
	done();

};

// Reload the browser when files change
var reloadBrowser = function (done) {
	if (!settings.reload) return done();
	browserSync.reload();
	done();
};

// Watch for changes
var watchSource = function (done) {
	watch([paths.input], series(exports.default, reloadBrowser));
	done();
};

var createToc = function (done) {
	var fs = require('fs');
	var fileList = '';

	fs.readdir('src/templates', function(err, files)  {
		files.forEach(function (file) {
			if(file.charAt(0) === "_" || file.indexOf(".html") === -1) {
				return;
			}
			var name = file.slice(0,-5);
			fileList += '\n<li><a class="wrapper-file-link" href="compiled/' + file +'">'+ name +'</a></li>';
		});

		fs.writeFileSync('src/toc.html', '<!-- Do not edit manually. Generated by gulp task "gulp toc" --> \n\n <ul>'+ fileList +'\n</ul>');
	});

	done();
};

/**
 * Export Tasks
 */

// Default task
// gulp
exports.default = series(
	cleanDist,

	
	copyAssets,
	buildStyles,
	
	compileIndex,
	
	compileTemplates,
	buildEmail
);

// Watch and reload
// gulp watch
exports.watch = series(
	exports.default,
	startServer,
	watchSource
);


// gulp toc
exports.toc = createToc;